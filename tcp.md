
## TCP协议

### 主要特点

* 面向连接
* 一对一
* 可靠交付
* 全双工
* 面向字节流

### 套接字Socket的含义

* Socket := IP + Port 
* TCP连接 ：= {Socket1, Socket2} 解释为两个Socket之间的连接

### TCP可靠传输的工作原理

* 停止等待协议
    
    * 超时重传
    * 超时计时器
    * 保留已发送分组的副本
    * 对数据分组和确认分组的编号
    * 重传时间的设置
    * 确认丢失和确认迟到
    * 信道利用率

* 连续ARQ协议
    
    * 发送方维持的滑动窗口
    
    * 累计确认
    
        * 容易实现，即使确认丢失也不必重传
        
        * 不能向发送方反映出接收方以及正确接收到的所有分组的信息
        
        
### TCP报文段的首部格式

* 源端口和目的端口

* 序号

* 确认号ack

* 数据偏移

* 保留位

* 紧急URG

* 确认位ACK(TCP连接过程中会用到)

* 推送PSH

* 复位RST

* 同步位SYN(在TCP连接过程中会用到)

* 终止FIN (在TCP释放过程中会用到)

* 窗口

* 检验和

* 紧急指针

* 选项
    * 最大报文长度MSS

    * 窗口扩大
    
    * 时间戳
    
        * 计算往返时间RTT
        
        * 防止序号绕回
        
    * 选择确认
    
### TCP可靠传输的实现

* 滑动窗口

    * 以字节为单位的
    
    * 结构划分 
    
        * 已发送并收到确认部分
        
        * 可发送部分
        
        * 不允许发送部分
        
    * 发送窗口
    
        * 描述发送窗口状态的三个指针
        
            * P1指向第一个已发送但未收到确认的字节的序号
            
            * P2指向第一个允许发送但尚未发送的字节的序号
            
            * P3指向第一个不允许发送的字节的序号
            
        * P3 - P1 通知窗口
        
        * P2 - P1 已发送但尚未收到确认的字节数
        
        * P3 - P2 允许发送但尚未发送的字节数
        
* 超时重传
    
    * TCP采用了一种自适应算法，该方法还在逐渐改进中
    
    * 算法中声明的相关变量
        
        * RTT(Round-Trip Time) 往返时间

        * RTT的加权平均往返时间RTTs
        
        
        * RTO(RetransmissionTime-Out)超时重传时间
        
        * RTTd(RTT的偏差的加权平均值)
        
    * 相关公式
    
        * 新的RTTs = (1 - a) * (旧的RTTs) + a * (新的RTT样本)，a推荐取值0.125
        
        * RTO = RTTs + 4 * RTTd
        
        * RTTd = (1 - b) * (旧的RTTd) + b * |RTTs - 新的RTT样本|， b的推荐值是0.25
        
    * 如何确定确认报文是对先发送的报文段的确认，还是对后来重传的报文段的确认？
    
        * Kran算法
        
        * 算法的改进
        
    * 选择确认SACK（Selective ACK）
    
        * 目的： 只传输缺少的数据而不重传已经正确到达接收方的数据
        
        * 前提：建立TCP连接时，需要在首部选项中加上“允许SACK”的选项
        
* 流量控制
    
    * 接收窗口(rwnd)变化
    * 持续计时器 + 零窗口探测报文段（解决非零窗口通知丢失造成死锁）
    * 发送方缓存控制
    
        * 缓存达到MSS(最大报文段长度)后发送
        
        * 发送方应用程序指明要求发送报文段

        * 发送方的一个计时器期限到了
        
* 拥塞控制
    
    * 原理
    * 几种拥塞的控制方法
        * 慢开始
        * 拥塞避免
        * 快重传
        * 快恢复
    
    * 如何确定网络发生了拥塞？ 答：只要发送方没有按时收到应当到达的确认报名，就可以猜想网络可能出现问题了
    

### 运输连接管理

* 三次握手建立连接
    
    * 建立连接的过程
    
        ![此处输入图片的描述][1]

    * 涉及状态
    
        * CLOSED
        
        * LISTEN
        
        * SYN-SENT 同步已发送
        
        * SYN-RCVD 同步确认
        
        * ESTABLISHED 连接建立
        
    * 涉及状态位
    
        * SYN 同步位，置1代表请求连接
    
        * ACK 确认位，置1代表确认收到
        
        * seq 序号
        
        * ack 确认号
        
    * 为什么需要三次握手？最后A还需要再确认一次？
    
        * 为了防止已经失效的连接请求报文段传送到了B
        
* 四次挥手连接释放
    
    * 释放连接的过程

        ![此处输入图片的描述][2]
        
    * 涉及状态
    
        * ESTABLISHED
        
        * FIN-WAIT-1 A请求关闭，但还没有收到B的确认
        
        * CLOSE-WAIT B收到了关闭请求，并且进行了确认，但是还有数据需要传送给A
        
        * FIN_WAIT-2 A收到了B的确认，但B的数据还没发送完，A还需要接收数据
        
        * LAST-ACK B没有数据要发送了，请求关闭连接
        
        * TIME-WAIT A收到了关闭请求，并确认
        
        * CLOSED B收到了A的关闭确认，A等待2MSL之后
    
    * 涉及状态位
    
        * FIN 终止控制位，置1代表请求关闭连接
        * ACK
        * ack
        * seq
        
    * 时间等待计时器
    
        * MSL 最长报文段寿命
        
        * 为什么最后A要等2MSL? 
        
            * 为了保证最后确认能被B收到，如果B没收到，B会超时重发关闭请求，如果A此时直接CLOSED了，就无法接受该请求
            
    * 保活计时器
    
        * 作用：防止客户端发生故障时，服务器空等请求
        
        * 每次接收请求时更新
        
        * 2小时无响应，就每75分钟发送一个探测报文段，连发10次确认客户端是否出现故障
    


  [1]: https://s1.ax1x.com/2018/09/02/PzpWX8.png
  [2]: https://s1.ax1x.com/2018/09/02/Pz9kjK.png
